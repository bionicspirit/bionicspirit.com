<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"><![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8" <![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9" <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>Towards a Better AtomicReference &#8211; Alexandru Nedelcu's Blog</title>
    

    <!-- Open Graph Meta -->
    <meta content="Alexandru Nedelcu's Blog" property="og:site_name">
    <meta content="Towards a Better AtomicReference" property="og:title">
    
      <meta content="On programming and personal projects" property="og:description">
    <meta content="https://alexn.org/blog/2013/05/07/towards-better-atomicreference-scala.html" property="og:url">
    <meta content="2013-05-07T00:00:00+00:00" property="article:published_time">
    
    <meta content="website" property="og:type">
    <meta property="og:image" content="https://alexn.org/assets/logo/800px.png" />
    <meta property="og:image:secure_url" content="https://alexn.org/assets/logo/800px.png" />
    <meta content="https://www.facebook.com/alexelcu" property="article:author">

    <!-- Twitter Cards -->
    
    <meta name="twitter:image:src" content="https://alexn.org/assets/logo/800px.png">
    <meta name="twitter:site" content="@alexelcu">
    <meta name="twitter:creator" content="@alexelcu">
    <meta name="twitter:title" content="Towards a Better AtomicReference">
    <meta name="twitter:url" content="https://alexn.org/blog/2013/05/07/towards-better-atomicreference-scala.html">
    
      <meta name="twitter:description" content="On programming and personal projects">
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico" sizes="16x16" />
    <link rel="icon" href="/assets/logo/32px.png" sizes="32x32" />
    <link rel="icon" href="/assets/logo/192px.png" sizes="192x192" />
    <link rel="icon" href="/assets/logo/270px.png" sizes="270x270" />
    <link rel="apple-touch-icon-precomposed" href="/assets/logo/180px.png" />
    <meta name="msapplication-TileImage" content="/assets/logo/270px.png" />

    <!-- Come and get me RSS readers -->
    <link rel="alternate" type="application/rss+xml" title="Alexandru Nedelcu's Blog" href="https://feed.alexn.org/" />

    <!-- Stylesheet -->
    <link rel="stylesheet" href="/assets/css/style.css?202004212329">
    <!--[if IE 8]><link rel="stylesheet" href="/assets/css/ie.css"><![endif]-->
    <link rel="canonical" href="https://alexn.org/blog/2013/05/07/towards-better-atomicreference-scala.html">

    <!-- Modernizr -->
    <script src="/assets/js/modernizr.custom.15390.js" type="text/javascript"></script>
</head>


<body>

    <div class="header">
    <div class="container">
        <h1 class="logo"><a href="/">Alex<span class="wide">andru</span> Nedelcu =&lt;&lt; Blog</a></h1>
        <nav class="nav-collapse">
            <ul class="noList">
                
                <li class="element first  ">
                    <a href="/">Home</a>
                </li>
                
                <li class="element   ">
                    <a href="/about.html">About</a>
                </li>
                
                <li class="element   last">
                    <a href="/subscribe.html">Subscribe</a>
                </li>
                
            </ul>
        </nav>
    </div>
</div><!-- end .header -->


   <div class="content">
      <div class="container">
         <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <h1 class="postTitle" itemprop="headline">Towards a Better AtomicReference</h1>
  <p class="meta">
    <meta itemscope itemprop="mainEntityOfPage"  itemType="https://schema.org/WebPage" itemid="https://alexn.org/blog/2013/05/07/towards-better-atomicreference-scala.html"/>
    <meta itemprop="datePublished" content="2013-05-07T00:00:00+0000"/>
    
    <time itemprop="dateCreated" datetime="2013-05-07T00:00:00+0000">May 7, 2013</time>
    | <nobr><span class="time">10</span> minute</nobr>
  </p>

  

  <div class="hidden" itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
    <meta itemprop="name" content="Alexandru Nedelcu's Blog">
    <meta itemprop="url" content="https://alexn.org/about.html">
    <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
      <meta itemprop="url" content="https://alexn.org/assets/raw/logo-green.png">
    </div>
  </div>
  <div class="hidden" itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alexandru Nedelcu" />
      <meta itemprop="url" content="https://alexn.org/about.html#alexelcu" />
      <meta itemprop="url" content="https://twitter.com/alexelcu" />
      <meta itemprop="url" content="https://www.facebook.com/alexelcu" />
      <meta itemprop="url" content="https://github.com/alexandru" />
    </div>
  

  <div id="content" itemprop="articleBody">
    <p class="intro withcap">
  The
  <a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/atomic/package-summary.html">AtomicReference</a>
  is like a container for a <code class="highlighter-rouge">volatile</code> reference. Usage of <code class="highlighter-rouge">volatile</code>
  references is useful for the issue of
  <a href="/blog/2013/03/14/jvm-multithreading-monitor-locks-visibility.html#visibility">visibility</a>
  in concurrent code, however <code class="highlighter-rouge">AtomicReference</code> also supports the atomic
  <a href="http://en.wikipedia.org/wiki/Compare-and-swap">Compare-and-Swap</a>
  operation (CAS for short), which is the pillar of all non-blocking
  data-structures and algorithms built on top of the JVM, including
  complex ones like the <code class="highlighter-rouge">ConcurrentLinkedQueue</code>, an implementation based
  on the
  <a href="http://www.cs.rochester.edu/u/michael/PODC96.html">Michael-Scott non-blocking queues</a>.
</p>

<p>However, the interface provided leaves something to be desired:</p>

<ul>
  <li>the <a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet%28V,%20V%29">compareAndSet</a>
operation is too low level and for 99% of everything we do in our day to day
code it can be replaced with something much better, as we’ll see</li>
  <li>the classes from the <code class="highlighter-rouge">java.util.concurrent.atomic</code> package do not
implement a common interface, so you can’t use an
<a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/atomic/AtomicInteger.html">AtomicInteger</a>
in place of an <code class="highlighter-rouge">AtomicReference</code></li>
  <li><code class="highlighter-rouge">AtomicInteger</code> and <code class="highlighter-rouge">AtomicLong</code> provide <code class="highlighter-rouge">incrementAndGet</code>, which is
really useful in practice for keeping track of things in
non-blocking counters, but why should that be available only for
Ints and Longs?  Floats, Doubles, BigInt, BigDecimal and all kinds
of numbers can be incremented too</li>
</ul>

<p><strong>IMPORTANT UPDATE (March 31, 2014):</strong> The content of this article is slightly obsolete, though
still has pedagogical value. For an up to date article on my Atomic references, checkout the wiki page maintained for project <a href="https://github.com/alexandru/monifu/">Monifu</a>: <a href="https://github.com/alexandru/monifu/blob/master/docs/atomic.md">Atomic References</a></p>

<!-- read more -->

<p>This is a simple and working example of how Scala can improve your
code tremendously. And I’m basically describing the implementation of
my own <code class="highlighter-rouge">shifter.concurrency.atomic.Ref</code>. You can:</p>

<ul>
  <li>see the code in <a href="https://github.com/alexandru/shifter/blob/master/core/src/main/scala/shifter/concurrency/atomic/Ref.scala">my GitHub repo</a></li>
  <li>checkout the <a href="http://shifter.alexn.org/api/current/core/#shifter.concurrency.atomic.package">API docs</a></li>
</ul>

<h2 id="the-common-interface">The Common Interface</h2>

<p>Lets start by mirroring the basics of AtomicReference:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="code"><code><span class="k">trait</span> <span class="nc">Ref</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">get</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="nf">set</span><span class="o">(</span><span class="n">update</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">compareAndSet</span><span class="o">(</span><span class="n">expect</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">update</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Ref</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">initial</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">RefAny</span><span class="o">(</span><span class="n">initial</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>With a generic implementation that for now just delegates to our inner
<code class="highlighter-rouge">AtomicReference</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="code"><code><span class="k">class</span> <span class="nc">RefAny</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">initial</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Ref</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">get</span> <span class="k">=</span> 
    <span class="nv">instance</span><span class="o">.</span><span class="py">get</span><span class="o">()</span>  
  <span class="k">def</span> <span class="nf">set</span><span class="o">(</span><span class="n">update</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> 
    <span class="nv">instance</span><span class="o">.</span><span class="py">set</span><span class="o">(</span><span class="n">update</span><span class="o">)</span>  
  <span class="k">def</span> <span class="nf">compareAndSet</span><span class="o">(</span><span class="n">expect</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">update</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> 
    <span class="nv">instance</span><span class="o">.</span><span class="py">compareAndSet</span><span class="o">(</span><span class="n">expect</span><span class="o">,</span> <span class="n">update</span><span class="o">)</span>
	
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">val</span> <span class="nv">instance</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">AtomicReference</span><span class="o">(</span><span class="n">initial</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>As I was saying, the <code class="highlighter-rouge">compareAndSet</code> is too low level. Much better is
to work with transformations. How about defining a function with the
following signature:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="code"><code><span class="k">def</span> <span class="nf">transformAndGet</span><span class="o">(</span><span class="n">cb</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
</code></pre></div></div>

<p>And that can be used like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="code"><code><span class="k">val</span> <span class="nv">ref</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>

<span class="nv">ref</span><span class="o">.</span><span class="py">transformAndGet</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">)</span>
<span class="c1">// =&gt; 4</span>
</code></pre></div></div>

<p>Well, incrementing numbers is not the only thing that you can do. For
instance you could store and transform immutable data-structures, like a queue:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="code"><code><span class="k">import</span> <span class="nn">collection.immutable.Queue</span>

<span class="k">val</span> <span class="nv">ref</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">(</span><span class="nv">Queue</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span>

<span class="nv">ref</span><span class="o">.</span><span class="py">transformAndGet</span><span class="o">(</span><span class="n">q</span> <span class="k">=&gt;</span> <span class="nv">q</span><span class="o">.</span><span class="py">enqueue</span><span class="o">(</span><span class="s">"Alex"</span><span class="o">))</span>
</code></pre></div></div>

<p>How about that? We got ourselves a non-blocking queue, without having
to implement the dreadful Michael-Scott algorithm.</p>

<p>Implementing <code class="highlighter-rouge">Ref.transformAndGet</code> is easy:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="code"><code>  <span class="nd">@tailrec</span>
  <span class="k">final</span> <span class="k">def</span> <span class="nf">transformAndGet</span><span class="o">(</span><span class="n">cb</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">oldValue</span> <span class="k">=</span> <span class="n">get</span>
    <span class="k">val</span> <span class="nv">newValue</span> <span class="k">=</span> <span class="nf">cb</span><span class="o">(</span><span class="n">oldValue</span><span class="o">)</span>

    <span class="nf">if</span> <span class="o">(!</span><span class="nf">compareAndSet</span><span class="o">(</span><span class="n">oldValue</span><span class="o">,</span> <span class="n">newValue</span><span class="o">))</span>
	  <span class="c1">// tail-recursive call</span>
      <span class="nf">transformAndGet</span><span class="o">(</span><span class="n">cb</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="n">newValue</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>I’m using a tail-recursive function, guarded by the <code class="highlighter-rouge">tailrec</code>
annotation, because that’s how I roll. I also find it much more
readable and less error-prone. It creates a loop … as long as the
<code class="highlighter-rouge">compareAndSet</code> operation is unsuccessful, then it keeps trying.</p>

<p>We can also implement <code class="highlighter-rouge">Ref.getAndTransform</code>, which returns the old
value before the transformation occurred, instead of the update:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="code"><code>  <span class="nd">@tailrec</span>
  <span class="k">final</span> <span class="k">def</span> <span class="nf">getAndTransform</span><span class="o">(</span><span class="n">cb</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">oldValue</span> <span class="k">=</span> <span class="n">get</span>
    <span class="k">val</span> <span class="nv">update</span> <span class="k">=</span> <span class="nf">cb</span><span class="o">(</span><span class="n">oldValue</span><span class="o">)</span>

    <span class="nf">if</span> <span class="o">(!</span><span class="nf">compareAndSet</span><span class="o">(</span><span class="n">oldValue</span><span class="o">,</span> <span class="n">update</span><span class="o">))</span>
	  <span class="c1">// tail-recursive call</span>
      <span class="nf">getAndTransform</span><span class="o">(</span><span class="n">cb</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="n">oldValue</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>We can have other utilities too, like
<a href="http://shifter.alexn.org/api/current/core/index.html#shifter.concurrency.atomic.Ref@transformAndExtract[U]%28cb:T=%3E%28T,U%29%29:U">transformAndExtract</a>,
but lets move on to our next issue … incrementing numbers.</p>

<p>Of course, with our transformation functions, the presence of a
shortcut for incrementing numbers is not that required anymore,
however it’s still a nice shortcut that can also provide readability
and performance advantages. The problem with a generic
<code class="highlighter-rouge">AtomicReference</code> is that not all reference types are numbers that can
be incremented. Fortunately for us, Scala gives us
<a href="http://en.wikipedia.org/wiki/Type_class">Type Classes</a> and there is
already a type class defined in Scala’s standard library for numbers:
<a href="http://www.scala-lang.org/api/current/index.html#scala.math.Numeric">Numeric[T]</a>.</p>

<p>What <code class="highlighter-rouge">Numeric[T]</code> does is to define, amongst others, the <code class="highlighter-rouge">sum</code>
operation for type <code class="highlighter-rouge">T</code> and of course the value for <code class="highlighter-rouge">one</code>. And we don’t
need more than that.</p>

<p>So we can define our <code class="highlighter-rouge">Ref.incrementAndGet</code> function, in a generic way,
like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="code"><code>  <span class="k">def</span> <span class="nf">incrementAndGet</span><span class="o">(</span><span class="k">implicit</span> <span class="n">num</span> <span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span>
    <span class="nf">transformAndGet</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nv">num</span><span class="o">.</span><span class="py">plus</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nv">num</span><span class="o">.</span><span class="py">one</span><span class="o">))</span>
</code></pre></div></div>

<p>And lo and behold, this stuff works for any kind of number, not just
Ints and Longs:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="code"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">ref</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">(</span><span class="nc">BigInt</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
<span class="n">ref</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">scala.math.BigInt</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">ref</span><span class="o">.</span><span class="py">incrementAndGet</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">scala.math.BigInt</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div></div>

<p>Best of all, if we try doing this on things that aren’t numbers, then
it fails with a compile-time error:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="code"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">ref</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">(</span><span class="s">"hello"</span><span class="o">)</span>
<span class="n">ref</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">(</span><span class="n">hello</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">ref</span><span class="o">.</span><span class="py">incrementAndGet</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">9</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">implicit</span> <span class="kt">value</span> <span class="kt">for</span> <span class="kt">parameter</span> <span class="kt">num:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
              <span class="nv">ref</span><span class="o">.</span><span class="py">incrementAndGet</span>
                  <span class="o">^</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">AtomicInteger</code> from Java’s standard library already has an
<code class="highlighter-rouge">incrementAndGet</code> and who knows, it might be more efficient than our
implementation. Maybe at some point it will get translated into a
single processor instruction. So we can take advantage of that by
specializing our <code class="highlighter-rouge">Ref</code> for <code class="highlighter-rouge">Int</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="code"><code><span class="k">final</span> <span class="k">class</span> <span class="nc">RefInt</span><span class="o">(</span><span class="n">initialValue</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Ref</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// ....</span>
  
  <span class="k">override</span> <span class="k">def</span> <span class="nf">incrementAndGet</span><span class="o">(</span><span class="k">implicit</span> <span class="n">num</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="nv">instance</span><span class="o">.</span><span class="py">incrementAndGet</span><span class="o">()</span>

  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">val</span> <span class="nv">instance</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">AtomicInteger</span><span class="o">(</span><span class="n">initialValue</span><span class="o">)</span>
<span class="o">}</span>

</code></pre></div></div>

<p>And then we can make our primary constructor return a <code class="highlighter-rouge">RefInt</code>, in
case the initial value is an <code class="highlighter-rouge">Int</code>. Well, here’s how the code in
<code class="highlighter-rouge">shifter.concurrency.atomic.Ref</code> looks like:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="code"><code><span class="k">object</span> <span class="nc">Ref</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">initialValue</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">RefInt</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">RefInt</span><span class="o">(</span><span class="n">initialValue</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">initialValue</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">RefLong</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">RefLong</span><span class="o">(</span><span class="n">initialValue</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">initialValue</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">RefBoolean</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">RefBoolean</span><span class="o">(</span><span class="n">initialValue</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">initialValue</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">RefAny</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">initialValue</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>There is still one difference between a <code class="highlighter-rouge">Ref[Int]</code> and
<code class="highlighter-rouge">AtomicInteger</code>. Our interface will be guilty of
<a href="http://en.wikipedia.org/wiki/Object_type_%28object-oriented_programming%29#Boxing">boxing and unboxing</a>
the integers passed to those functions. And in the wild, using
<code class="highlighter-rouge">AtomicInteger</code> for cheap and non-blocking counters is really common,
so it’s a pitty if we’ll have performance degradation here.</p>

<p>The fix is easy though. The Scala compiler can specialize our type T
for primitive types, if we annotate our type like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="code"><code><span class="k">trait</span> <span class="nc">Ref</span><span class="o">[</span><span class="kt">@specialized</span><span class="o">(</span><span class="kt">scala.Int</span>, <span class="kt">scala.Long</span>, <span class="kt">scala.Boolean</span><span class="o">)</span> <span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In the example, the compiler will specialize the <code class="highlighter-rouge">Ref[T]</code> interface
for Ints, Longs and Booleans, to avoid the boxing and unboxing
overhead.</p>

<p>What this will do is to generate specialized methods for these
primitive types. You can inspect the generated interface easily with
the <code class="highlighter-rouge">javap</code> utility. For instance, let’s see what it generates for
<code class="highlighter-rouge">compareAndSet</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="code"><code><span class="n">$</span> <span class="n">javap</span> <span class="nv">shifter</span><span class="o">.</span><span class="py">concurrency</span><span class="o">.</span><span class="py">atomic</span><span class="o">.</span><span class="py">Ref</span> <span class="o">|</span> <span class="n">grep</span> <span class="n">compareAndSet</span>
  <span class="n">public</span> <span class="k">abstract</span> <span class="n">boolean</span> <span class="nf">compareAndSet</span><span class="o">(</span><span class="n">T</span><span class="o">,</span> <span class="n">T</span><span class="o">);</span>
  <span class="n">public</span> <span class="k">abstract</span> <span class="n">boolean</span> <span class="nf">compareAndSet$mcZ$sp</span><span class="o">(</span><span class="n">boolean</span><span class="o">,</span> <span class="n">boolean</span><span class="o">);</span>
  <span class="n">public</span> <span class="k">abstract</span> <span class="n">boolean</span> <span class="nf">compareAndSet$mcI$sp</span><span class="o">(</span><span class="n">int</span><span class="o">,</span> <span class="n">int</span><span class="o">);</span>
  <span class="n">public</span> <span class="k">abstract</span> <span class="n">boolean</span> <span class="nf">compareAndSet$mcJ$sp</span><span class="o">(</span><span class="n">long</span><span class="o">,</span> <span class="n">long</span><span class="o">);</span>
</code></pre></div></div>

<p>Or for <code class="highlighter-rouge">incrementAndGet</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="code"><code><span class="n">$</span> <span class="n">javap</span> <span class="nv">shifter</span><span class="o">.</span><span class="py">concurrency</span><span class="o">.</span><span class="py">atomic</span><span class="o">.</span><span class="py">Ref</span> <span class="o">|</span> <span class="n">grep</span> <span class="n">incrementAndGet</span>
  <span class="n">public</span> <span class="k">abstract</span> <span class="n">T</span> <span class="nf">incrementAndGet</span><span class="o">(</span><span class="nv">scala</span><span class="o">.</span><span class="py">math</span><span class="o">.</span><span class="py">Numeric</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;);</span>
  <span class="n">public</span> <span class="k">abstract</span> <span class="n">boolean</span> <span class="nf">incrementAndGet$mcZ$sp</span><span class="o">(</span><span class="nv">scala</span><span class="o">.</span><span class="py">math</span><span class="o">.</span><span class="py">Numeric</span><span class="o">&lt;</span><span class="nv">java</span><span class="o">.</span><span class="py">lang</span><span class="o">.</span><span class="py">Object</span><span class="o">&gt;);</span>
  <span class="n">public</span> <span class="k">abstract</span> <span class="n">int</span> <span class="nf">incrementAndGet$mcI$sp</span><span class="o">(</span><span class="nv">scala</span><span class="o">.</span><span class="py">math</span><span class="o">.</span><span class="py">Numeric</span><span class="o">&lt;</span><span class="nv">java</span><span class="o">.</span><span class="py">lang</span><span class="o">.</span><span class="py">Object</span><span class="o">&gt;);</span>
  <span class="n">public</span> <span class="k">abstract</span> <span class="n">long</span> <span class="nf">incrementAndGet$mcJ$sp</span><span class="o">(</span><span class="nv">scala</span><span class="o">.</span><span class="py">math</span><span class="o">.</span><span class="py">Numeric</span><span class="o">&lt;</span><span class="nv">java</span><span class="o">.</span><span class="py">lang</span><span class="o">.</span><span class="py">Object</span><span class="o">&gt;);</span>
</code></pre></div></div>

<p>So it’s basically method overloading done by the Scala
compiler. Clearly this adds some overhead in the generated .class
files and it might not do what you think it does, so use it only if
you really need it.</p>

<p>As I was saying in the beginning, make sure to also (<strong>links update March 31, 2014</strong>):</p>

<ul>
  <li>see the code in <a href="https://github.com/alexandru/monifu">project Monifu</a></li>
  <li>checkout the <a href="http://www.monifu.org/monifu-core/current/api/#monifu.concurrent.atomic.package">API docs</a></li>
</ul>

<p>Also, you may be interested in using
<strong><a href="http://nbronson.github.io/scala-stm/">scala-stm</a></strong>, a library for
<em>shared transactional memory</em>, that basically gives you the ability to
orchestrate multiple atomic references at once.</p>

  </div>

  <div id="article-details">
    
    <time itemprop="dateModified" content="2013-05-07T00:00:00+0000">
        Published: May 7, 2013
    </time>
    
      | Written by <a href="https://alexn.org/about.html#alexelcu" itemprop="url" rel="author">Alexandru Nedelcu</a>
    

    <div id="all-categories">
      Tags:
      
        
        <a href="/tag/languages/" class="category">languages</a>
      
         | 
        <a href="/tag/functional/" class="category">functional</a>
      
         | 
        <a href="/tag/scala/" class="category">scala</a>
      
         | 
        <a href="/tag/java/" class="category">java</a>
      
         | 
        <a href="/tag/multithreading/" class="category">multithreading</a>
      
         | 
        <a href="/tag/concurrency/" class="category">concurrency</a>
      
    </div>
  </div>

  
  <div class="related">
    <h2>Related Articles</h2>
    <div class="container">
      
      

      
      
      <div class="item">
        <a class="related-link" href="/blog/2012/11/02/scala-functional-programming-type-classes.html">
          On Scala, Functional Programming and Type-Classes
        </a>
        <div class="related-meta">
          <div class="tags">
            
            
              <a href="/tag/languages" class="tag">languages</a>
            
               | <a href="/tag/functional" class="tag">functional</a>
            
               | <a href="/tag/scala" class="tag">scala</a>
            
               | <a href="/tag/clojure" class="tag">clojure</a>
            
               | <a href="/tag/java" class="tag">java</a>
                        
          </div>
          <time>November 2, 2012</time>
        </div>
        <div class="clearfix"></div>
      </div>
      
      
      
      <div class="item">
        <a class="related-link" href="/blog/2017/01/30/asynchronous-programming-scala.html">
          Asynchronous Programming and Scala
        </a>
        <div class="related-meta">
          <div class="tags">
            
            
              <a href="/tag/best of" class="tag">best of</a>
            
               | <a href="/tag/scala" class="tag">scala</a>
            
               | <a href="/tag/asynchrony" class="tag">asynchrony</a>
            
               | <a href="/tag/concurrency" class="tag">concurrency</a>
                        
          </div>
          <time>January 30, 2017</time>
        </div>
        <div class="clearfix"></div>
      </div>
      
      
      
      <div class="item">
        <a class="related-link" href="/blog/2018/02/12/in-defense-oofp.html">
          In Defense of OOFP
        </a>
        <div class="related-meta">
          <div class="tags">
            
            
              <a href="/tag/best of" class="tag">best of</a>
            
               | <a href="/tag/oop" class="tag">oop</a>
            
               | <a href="/tag/fp" class="tag">fp</a>
            
               | <a href="/tag/haskell" class="tag">haskell</a>
            
               | <a href="/tag/scala" class="tag">scala</a>
                        
          </div>
          <time>February 12, 2018</time>
        </div>
        <div class="clearfix"></div>
      </div>
      
      
      
      <div class="item">
        <a class="related-link" href="/blog/2018/05/06/bifunctor-io.html">
          On Bifunctor IO and Java's Checked Exceptions
        </a>
        <div class="related-meta">
          <div class="tags">
            
            
              <a href="/tag/best of" class="tag">best of</a>
            
               | <a href="/tag/fp" class="tag">fp</a>
            
               | <a href="/tag/typelevel" class="tag">typelevel</a>
            
               | <a href="/tag/scala" class="tag">scala</a>
            
               | <a href="/tag/haskell" class="tag">haskell</a>
                        
          </div>
          <time>May 6, 2018</time>
        </div>
        <div class="clearfix"></div>
      </div>
      
      
      <div class="clearfix"></div>
    </div>
  </div>
  

  
</article>

      </div>
   </div><!-- end .content -->

   <div class="footer">
  
  <div class="container">
    <div class="contributions">
      <h2>Feedback?</h2>

<p>
  If you wish to discus this article, an email would be most welcome:
  <!--sse-->
  <script>
    (function () {
      var lhs = "comments";
      var rhs = "m9.alexn.org";
      var subject = "Comment on `Towards a Better AtomicReference`";
      document.write("<a href=\"mailto");
      document.write(":" + lhs + "@");
      document.write(rhs);
      if (subject) { document.write("?subject=" + subject); }
      document.write("\">" + lhs + "@" + rhs + "<\/a>");
    })()
  </script>
  <noscript>
    <em>Email address is protected by JavaScript, activate it to see it!</em>
  </noscript>
  <!--/sse-->
</p>

<p>
  If you noticed a typo, help me by submitting a pull request:
  <a style="white-space: nowrap;" href="https://github.com/alexandru/alexn.org/blob/master/_posts/2013-05-07-towards-better-atomicreference-scala.md" target="_blank">Edit Page on GitHub</a>
</p>

    </div>  
  </div>
  

  <div class="bottom">
    <div class="container">
      <span class="copy">
          &copy; 2020
      </span>
      <span class="links">
        <a href="/docs/license.html">License</a> |
        <a href="/docs/privacy-policy.html">Privacy Policy</a> |
        <a href="/about.html#contact">Contact</a>
      </span>
    </div>
  </div>
</div><!-- end .footer -->

   <script async src="/assets/js-managed/jquery/dist/jquery.slim.min.js" type="text/javascript"></script>
<script async src="/assets/js/dropcap.min.js" type="text/javascript"></script>
<script async src="/assets/js/responsive-nav.min.js" type="text/javascript"></script>
<script async src="/assets/js/scripts.js" type="text/javascript"></script>


<!-- Google Analytics: change UA-XXXXX-X to be your site's ID. -->
<script type="text/javascript">
function _gaLoad() {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-84530423-1', {
    'cookieName': '_gaAlexNOrg',
    'cookieExpires': 60 * 60 * 24 * 30 * 3  // 3 months, in seconds
  });
  ga('set', 'anonymizeIp', true);
  ga('send', 'pageview');

  // Click handler
  $(function () {
    $('a[href]').each(function (idx, elem) {
      var it = $(elem);
      var href = it.attr('href');

      if (href.match(/^https?[:]\/\//) && !href.match(/alexn\.org/)) {
        it.click(_gaEvent('general', 'click', 'external-link', href));
      } else if (href.match(/^#/)) {
        it.click(_gaEvent('general', 'click', 'page-anchor', href));
      } else {
        it.click(_gaEvent('general', 'click', 'internal-link', href));
      }
    })
  })
}

function _gaEvent(category, action, label, value) {
  return function () {
    if (_doNotTrack || typeof ga !== 'function') {
      return;
    }
    ga(function () {
      ga('send', 'event', category, action, label, value);
    });
   }
}

// Checks DO-NOT-TRACK status
window._doNotTrack = false;
if (window.doNotTrack || navigator.doNotTrack || navigator.msDoNotTrack || 'msTrackingProtectionEnabled' in window.external) {
  window._doNotTrack = window.doNotTrack == "1" || navigator.doNotTrack == "yes" ||
    navigator.doNotTrack == "1" || navigator.msDoNotTrack == "1" ||
    ('msTrackingProtectionEnabled' in window.external && window.external.msTrackingProtectionEnabled());
}
if (!_doNotTrack) {
  console.log("Analytics are loading.")
  _gaLoad();
} else if (typeof(console) !== "undefined") {
  console.log("Analytics are off due to Do Not Track setting!");
}
</script>



   
   <!-- <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/unique-methods/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">window.dojoRequire(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us20.list-manage.com","uuid":"6c8297e886b517d8535e8410e","lid":"a3391a44b0","uniqueMethods":true}) })</script> -->
   
</body>

</html>
